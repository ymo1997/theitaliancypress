<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Asset Processor - The Italian Cypress</title>
    <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3d5c3e;
            --primary-light: #7a9a7b;
            --bg: #faf9f6;
            --card-bg: #ffffff;
            --text: #2c3e2d;
            --text-muted: #5a6b5a;
            --border: #e0e5e0;
            --success: #4caf50;
            --warning: #ff9800;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        header h1 {
            font-size: 2rem;
            color: var(--primary);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        header p {
            color: var(--text-muted);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border: 1px solid var(--border);
        }

        .card h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--primary-light);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg);
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--primary);
            background: #f0f5f0;
        }

        .upload-zone svg {
            width: 48px;
            height: 48px;
            color: var(--primary-light);
            margin-bottom: 1rem;
        }

        .upload-zone p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .upload-zone .formats {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            color: var(--primary-light);
        }

        #fileInput {
            display: none;
        }

        /* Controls */
        .control-group {
            margin-bottom: 1rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .size-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .size-btn {
            padding: 0.5rem;
            border: 1px solid var(--border);
            background: var(--bg);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .size-btn:hover {
            border-color: var(--primary-light);
        }

        .size-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .custom-size {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .custom-size input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .slider-group input[type="range"] {
            flex: 1;
            accent-color: var(--primary);
        }

        .slider-group span {
            min-width: 40px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            accent-color: var(--primary);
            width: 16px;
            height: 16px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2d4a2e;
        }

        .btn-secondary {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f0f5f0;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Main Content */
        .content {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .image-count {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .view-toggle {
            display: flex;
            background: var(--card-bg);
            border-radius: 6px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .view-toggle button {
            padding: 0.5rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .view-toggle button.active {
            background: var(--primary);
            color: white;
        }

        /* Image Grid */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .image-card {
            background: var(--card-bg);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            position: relative;
        }

        .image-card.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        .image-preview {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: repeating-conic-gradient(#e8e8e8 0% 25%, #fff 0% 50%) 50% / 16px 16px;
            position: relative;
            overflow: hidden;
        }

        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .image-preview .toggle-view {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .image-card:hover .toggle-view {
            opacity: 1;
        }

        .image-info {
            padding: 0.75rem;
        }

        .image-name {
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-status {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.pending {
            background: var(--border);
        }

        .status-dot.processing {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        .status-dot.done {
            background: var(--success);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .image-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0 0.75rem 0.75rem;
        }

        .image-actions button {
            flex: 1;
            padding: 0.4rem;
            border: 1px solid var(--border);
            background: var(--bg);
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .image-actions button:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Progress Overlay */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .progress-overlay.active {
            display: flex;
        }

        .progress-modal {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .progress-modal h3 {
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .progress-bar {
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-bar-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: -1;
            }
        }

        /* Loading spinner for ML model */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .model-status {
            text-align: center;
            padding: 1rem;
            background: #fff3cd;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.85rem;
        }

        .model-status.ready {
            background: #d4edda;
            color: #155724;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸŒ² Game Asset Processor</h1>
            <p>Upload, remove backgrounds, crop, and export game-ready sprites</p>
        </header>

        <div class="main-layout">
            <aside class="sidebar">
                <!-- Upload Section -->
                <div class="card">
                    <h3>Upload Images</h3>
                    <div class="upload-zone" id="uploadZone">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        <p>Drag & drop images here</p>
                        <p>or click to browse</p>
                        <p class="formats">PNG, JPG, WEBP</p>
                    </div>
                    <input type="file" id="fileInput" multiple accept="image/png,image/jpeg,image/webp">
                </div>

                <!-- Processing Options -->
                <div class="card">
                    <h3>Processing</h3>
                    <div id="modelStatus" class="model-status">
                        Loading background removal model...
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" id="removeBackgroundBtn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                            Remove Backgrounds
                        </button>
                        <button class="btn btn-secondary" id="autoCropBtn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                            </svg>
                            Auto Crop & Center
                        </button>
                    </div>
                </div>

                <!-- Size Options -->
                <div class="card">
                    <h3>Output Size</h3>
                    <div class="control-group">
                        <label>Preset Sizes</label>
                        <div class="size-presets">
                            <button class="size-btn" data-size="64">64Ã—64</button>
                            <button class="size-btn" data-size="128">128Ã—128</button>
                            <button class="size-btn active" data-size="256">256Ã—256</button>
                            <button class="size-btn" data-size="512">512Ã—512</button>
                        </div>
                        <div class="custom-size">
                            <input type="number" id="customSize" placeholder="Custom size" min="16" max="2048">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Padding</label>
                        <div class="slider-group">
                            <input type="range" id="paddingSlider" min="0" max="30" value="10">
                            <span id="paddingValue">10%</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="fillFrame" checked>
                            <label for="fillFrame">Fill ~80% of frame</label>
                        </div>
                    </div>
                </div>

                <!-- Export -->
                <div class="card">
                    <h3>Export</h3>
                    <div class="btn-group">
                        <button class="btn btn-primary" id="exportAllBtn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            Download All as ZIP
                        </button>
                        <button class="btn btn-secondary" id="clearAllBtn" disabled>
                            Clear All
                        </button>
                    </div>
                </div>
            </aside>

            <main class="content">
                <div class="toolbar">
                    <div class="toolbar-left">
                        <span class="image-count" id="imageCount">0 images</span>
                        <div class="view-toggle">
                            <button class="active" data-view="processed">Processed</button>
                            <button data-view="original">Original</button>
                        </div>
                    </div>
                </div>

                <div id="imageGrid" class="image-grid">
                    <div class="empty-state" id="emptyState">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                        <p>No images uploaded yet</p>
                        <p>Drag & drop or click upload to get started</p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Progress Overlay -->
    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-modal">
            <div class="loading-spinner"></div>
            <h3 id="progressTitle">Processing...</h3>
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressFill"></div>
            </div>
            <p class="progress-text" id="progressText">0 of 0 images</p>
        </div>
    </div>

    <script>
        // State
        let images = [];
        let selectedSize = 256;
        let padding = 10;
        let fillFrame = true;
        let currentView = 'processed';
        let bgRemovalModel = null;
        let modelReady = false;

        // DOM Elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const imageGrid = document.getElementById('imageGrid');
        const emptyState = document.getElementById('emptyState');
        const imageCount = document.getElementById('imageCount');
        const removeBackgroundBtn = document.getElementById('removeBackgroundBtn');
        const autoCropBtn = document.getElementById('autoCropBtn');
        const exportAllBtn = document.getElementById('exportAllBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const paddingSlider = document.getElementById('paddingSlider');
        const paddingValue = document.getElementById('paddingValue');
        const customSizeInput = document.getElementById('customSize');
        const fillFrameCheckbox = document.getElementById('fillFrame');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progressTitle = document.getElementById('progressTitle');
        const modelStatus = document.getElementById('modelStatus');

        // Initialize background removal model
        async function initBackgroundRemoval() {
            try {
                modelStatus.textContent = 'Loading background removal model (this may take a moment)...';

                // Check if the library is loaded
                if (typeof imglyRemoveBackground !== 'undefined') {
                    // Pre-warm the model by doing a small test
                    const testCanvas = document.createElement('canvas');
                    testCanvas.width = 10;
                    testCanvas.height = 10;
                    const ctx = testCanvas.getContext('2d');
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, 10, 10);

                    modelReady = true;
                    modelStatus.textContent = 'âœ“ Background removal ready';
                    modelStatus.classList.add('ready');
                    updateButtons();
                } else {
                    throw new Error('Library not loaded');
                }
            } catch (error) {
                console.error('Failed to load background removal:', error);
                modelStatus.textContent = 'âš  Background removal unavailable - using fallback';
                modelStatus.classList.add('ready');
                modelReady = true; // Allow using fallback
                updateButtons();
            }
        }

        // Upload handlers
        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            const validTypes = ['image/png', 'image/jpeg', 'image/webp'];

            for (const file of files) {
                if (validTypes.includes(file.type)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const imageData = {
                                id: Date.now() + Math.random(),
                                name: file.name.replace(/\.[^/.]+$/, ''),
                                original: img,
                                originalDataUrl: e.target.result,
                                processed: null,
                                processedDataUrl: null,
                                status: 'pending'
                            };
                            images.push(imageData);
                            renderImages();
                            updateButtons();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        }

        // Render images
        function renderImages() {
            const cards = images.map(img => createImageCard(img)).join('');
            imageGrid.innerHTML = cards || emptyState.outerHTML;
            imageCount.textContent = `${images.length} image${images.length !== 1 ? 's' : ''}`;

            // Attach event listeners
            document.querySelectorAll('.toggle-view').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseFloat(e.target.dataset.id);
                    const img = images.find(i => i.id === id);
                    if (img) {
                        const imgEl = e.target.parentElement.querySelector('img');
                        const isShowingOriginal = imgEl.src === img.originalDataUrl;
                        imgEl.src = isShowingOriginal && img.processedDataUrl ? img.processedDataUrl : img.originalDataUrl;
                        e.target.textContent = isShowingOriginal && img.processedDataUrl ? 'Original' : 'Processed';
                    }
                });
            });

            document.querySelectorAll('.download-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseFloat(e.target.dataset.id);
                    downloadImage(id);
                });
            });

            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseFloat(e.target.dataset.id);
                    images = images.filter(img => img.id !== id);
                    renderImages();
                    updateButtons();
                });
            });
        }

        function createImageCard(img) {
            const displayUrl = currentView === 'processed' && img.processedDataUrl
                ? img.processedDataUrl
                : img.originalDataUrl;

            const statusClass = img.status === 'done' ? 'done' : img.status === 'processing' ? 'processing' : 'pending';
            const statusText = img.status === 'done' ? 'Processed' : img.status === 'processing' ? 'Processing...' : 'Pending';

            return `
                <div class="image-card" data-id="${img.id}">
                    <div class="image-preview">
                        <img src="${displayUrl}" alt="${img.name}">
                        ${img.processedDataUrl ? `<button class="toggle-view" data-id="${img.id}">Original</button>` : ''}
                    </div>
                    <div class="image-info">
                        <div class="image-name" title="${img.name}">${img.name}</div>
                        <div class="image-status">
                            <span class="status-dot ${statusClass}"></span>
                            ${statusText}
                        </div>
                    </div>
                    <div class="image-actions">
                        <button class="download-btn" data-id="${img.id}" ${!img.processedDataUrl ? 'disabled' : ''}>Download</button>
                        <button class="remove-btn" data-id="${img.id}">Remove</button>
                    </div>
                </div>
            `;
        }

        // Update button states
        function updateButtons() {
            const hasImages = images.length > 0;
            const hasProcessed = images.some(img => img.processedDataUrl);

            removeBackgroundBtn.disabled = !hasImages || !modelReady;
            autoCropBtn.disabled = !hasImages;
            exportAllBtn.disabled = !hasProcessed;
            clearAllBtn.disabled = !hasImages;
        }

        // Size presets
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedSize = parseInt(btn.dataset.size);
                customSizeInput.value = '';
            });
        });

        customSizeInput.addEventListener('change', () => {
            const val = parseInt(customSizeInput.value);
            if (val >= 16 && val <= 2048) {
                selectedSize = val;
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
            }
        });

        // Padding slider
        paddingSlider.addEventListener('input', () => {
            padding = parseInt(paddingSlider.value);
            paddingValue.textContent = `${padding}%`;
        });

        // Fill frame checkbox
        fillFrameCheckbox.addEventListener('change', () => {
            fillFrame = fillFrameCheckbox.checked;
        });

        // View toggle
        document.querySelectorAll('.view-toggle button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentView = btn.dataset.view;
                renderImages();
            });
        });

        // Background removal
        removeBackgroundBtn.addEventListener('click', async () => {
            showProgress('Removing Backgrounds...', 0, images.length);

            for (let i = 0; i < images.length; i++) {
                const img = images[i];
                img.status = 'processing';
                renderImages();

                try {
                    const blob = await removeBackground(img.originalDataUrl);
                    const dataUrl = await blobToDataUrl(blob);

                    img.processedDataUrl = dataUrl;
                    img.status = 'done';
                } catch (error) {
                    console.error('Failed to remove background:', error);
                    // Fallback: just use original
                    img.processedDataUrl = img.originalDataUrl;
                    img.status = 'done';
                }

                updateProgress(i + 1, images.length);
                renderImages();
            }

            hideProgress();
            updateButtons();
        });

        async function removeBackground(imageDataUrl) {
            try {
                if (typeof imglyRemoveBackground !== 'undefined') {
                    const blob = await imglyRemoveBackground(imageDataUrl);
                    return blob;
                }
            } catch (error) {
                console.error('Background removal failed:', error);
            }

            // Fallback: return original as blob
            const response = await fetch(imageDataUrl);
            return await response.blob();
        }

        function blobToDataUrl(blob) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
        }

        // Auto crop and center
        autoCropBtn.addEventListener('click', async () => {
            showProgress('Cropping & Centering...', 0, images.length);

            for (let i = 0; i < images.length; i++) {
                const img = images[i];
                img.status = 'processing';
                renderImages();

                const sourceUrl = img.processedDataUrl || img.originalDataUrl;
                const croppedDataUrl = await autoCropAndCenter(sourceUrl);

                img.processedDataUrl = croppedDataUrl;
                img.status = 'done';

                updateProgress(i + 1, images.length);
                renderImages();
            }

            hideProgress();
            updateButtons();
        });

        async function autoCropAndCenter(imageDataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    // Create canvas to analyze image
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0);

                    // Get image data and find bounding box of non-transparent pixels
                    const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                    const bounds = findContentBounds(imageData);

                    // Calculate dimensions with padding
                    const paddingFactor = padding / 100;
                    const contentWidth = bounds.maxX - bounds.minX;
                    const contentHeight = bounds.maxY - bounds.minY;
                    const maxDim = Math.max(contentWidth, contentHeight);
                    const paddedSize = Math.ceil(maxDim * (1 + paddingFactor * 2));

                    // Create output canvas
                    const outputCanvas = document.createElement('canvas');
                    outputCanvas.width = selectedSize;
                    outputCanvas.height = selectedSize;
                    const outputCtx = outputCanvas.getContext('2d');

                    // Clear with transparent background
                    outputCtx.clearRect(0, 0, selectedSize, selectedSize);

                    // Calculate scale to fill ~80% of frame if enabled
                    let scale;
                    if (fillFrame) {
                        const targetSize = selectedSize * 0.8;
                        scale = targetSize / maxDim;
                    } else {
                        scale = selectedSize / paddedSize;
                    }

                    // Calculate position to center
                    const scaledWidth = contentWidth * scale;
                    const scaledHeight = contentHeight * scale;
                    const offsetX = (selectedSize - scaledWidth) / 2;
                    const offsetY = (selectedSize - scaledHeight) / 2;

                    // Draw cropped and centered image
                    outputCtx.drawImage(
                        img,
                        bounds.minX, bounds.minY, contentWidth, contentHeight,
                        offsetX, offsetY, scaledWidth, scaledHeight
                    );

                    resolve(outputCanvas.toDataURL('image/png'));
                };
                img.src = imageDataUrl;
            });
        }

        function findContentBounds(imageData) {
            const { width, height, data } = imageData;
            let minX = width, minY = height, maxX = 0, maxY = 0;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const alpha = data[(y * width + x) * 4 + 3];
                    if (alpha > 10) { // Non-transparent pixel
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // Handle edge case of fully transparent image
            if (minX > maxX || minY > maxY) {
                return { minX: 0, minY: 0, maxX: width, maxY: height };
            }

            return { minX, minY, maxX: maxX + 1, maxY: maxY + 1 };
        }

        // Export functions
        async function downloadImage(id) {
            const img = images.find(i => i.id === id);
            if (!img || !img.processedDataUrl) return;

            const link = document.createElement('a');
            link.download = `${img.name}_processed.png`;
            link.href = img.processedDataUrl;
            link.click();
        }

        exportAllBtn.addEventListener('click', async () => {
            const processedImages = images.filter(img => img.processedDataUrl);
            if (processedImages.length === 0) return;

            showProgress('Creating ZIP...', 0, processedImages.length);

            const zip = new JSZip();

            for (let i = 0; i < processedImages.length; i++) {
                const img = processedImages[i];
                const base64Data = img.processedDataUrl.split(',')[1];
                zip.file(`${img.name}_processed.png`, base64Data, { base64: true });
                updateProgress(i + 1, processedImages.length);
            }

            const content = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.download = 'processed_assets.zip';
            link.href = URL.createObjectURL(content);
            link.click();
            URL.revokeObjectURL(link.href);

            hideProgress();
        });

        clearAllBtn.addEventListener('click', () => {
            images = [];
            renderImages();
            updateButtons();
        });

        // Progress helpers
        function showProgress(title, current, total) {
            progressTitle.textContent = title;
            progressText.textContent = `${current} of ${total} images`;
            progressFill.style.width = `${(current / total) * 100}%`;
            progressOverlay.classList.add('active');
        }

        function updateProgress(current, total) {
            progressText.textContent = `${current} of ${total} images`;
            progressFill.style.width = `${(current / total) * 100}%`;
        }

        function hideProgress() {
            progressOverlay.classList.remove('active');
        }

        // Initialize
        initBackgroundRemoval();
    </script>
</body>
</html>
